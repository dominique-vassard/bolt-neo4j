defmodule BoltNeo4j.Packstream.DecoderTest do
  use ExUnit.Case

  alias BoltNeo4j.Packstream.Decoder

  defmodule TestStruct do
    defstruct [:id, :value]
  end

  test "Decode common types" do
    Enum.each(Decoder.available_versions(), fn version ->
      assert [true] == Decoder.decode(<<0xC3>>, version)
      assert [42] = Decoder.decode(<<0x2A>>, version)

      assert [7.7] =
               Decoder.decode(<<0xC1, 0x40, 0x1E, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCD>>, version)

      assert ["hello"] = Decoder.decode(<<0x85, 0x68, 0x65, 0x6C, 0x6C, 0x6F>>, version)
      assert [[]] = Decoder.decode(<<0x90>>, version)
      assert [[2, 4]] = Decoder.decode(<<0x92, 0x2, 0x4>>, version)
      assert [%{"ok" => 5}] = Decoder.decode(<<0xA1, 0x82, 0x6F, 0x6B, 0x5>>, version)

      assert [[sig: 1, fields: [%{"id" => 1, "value" => "hello"}]]] =
               Decoder.decode(
                 <<0xB3, 0x1, 0xA2, 0x82, 0x69, 0x64, 0x1, 0x85, 0x76, 0x61, 0x6C, 0x75, 0x65,
                   0x85, 0x68, 0x65, 0x6C, 0x6C, 0x6F>>,
                 version
               )

      assert {:success, %{"server" => "Neo4j/3.4.1"}} =
               Decoder.decode_message(
                 <<0xB1, 0x70, 0xA1, 0x86, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x8B, 0x4E, 0x65,
                   0x6F, 0x34, 0x6A, 0x2F, 0x33, 0x2E, 0x34, 0x2E, 0x31>>,
                 version
               )

      failure_hex =
        <<0xB1, 0x7F, 0xA2, 0x84, 0x63, 0x6F, 0x64, 0x65, 0xD0, 0x25, 0x4E, 0x65, 0x6F, 0x2E,
          0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x45, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0x53, 0x65,
          0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2E, 0x55, 0x6E, 0x61, 0x75, 0x74, 0x68, 0x6F,
          0x72, 0x69, 0x7A, 0x65, 0x64, 0x87, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0xD0,
          0x39, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73,
          0x20, 0x75, 0x6E, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20,
          0x64, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6E, 0x74,
          0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72,
          0x65, 0x2E>>

      failure =
        {:failure,
         %{
           "code" => "Neo.ClientError.Security.Unauthorized",
           "message" => "The client is unauthorized due to authentication failure."
         }}

      assert ^failure = Decoder.decode_message(failure_hex, version)

      assert {:record, [1]} = Decoder.decode_message(<<0xB1, 0x71, 0x91, 0x1>>, version)

      assert {:ignored, _} = Decoder.decode_message(<<0xB0, 0x7E>>, version)
    end)
  end

  test "Decode in v2" do
    assert [~D[2018-07-29]] = Decoder.decode(<<0xB1, 0x44, 0xC9, 0x45, 0x4D>>, 2)

    ttz = [
      %BoltNeo4j.Types.TimeWithTZ{
        time: ~T[12:45:30.250000],
        timezone_offset: 3600
      }
    ]

    assert ^ttz =
             Decoder.decode(
               <<0xB2, 0x54, 0xCB, 0x0, 0x0, 0x29, 0xC5, 0xF8, 0x3C, 0x56, 0x80, 0xC9, 0xE,
                 0x10>>,
               2
             )

    assert [~T[17:34:45.000000]] =
             Decoder.decode(<<0xB1, 0x74, 0xCB, 0x0, 0x0, 0x39, 0x8E, 0xAF, 0xF1, 0xD2, 0x0>>, 2)

    duration = [%BoltNeo4j.Types.Duration{days: 34, months: 15, nanoseconds: 5550, seconds: 54}]
    assert ^duration = Decoder.decode(<<0xB4, 0x45, 0xF, 0x22, 0x36, 0xC9, 0x15, 0xAE>>, 2)
  end
end
